// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (c) Microsoft Corporation. All rights reserved.


/****************************************************************************
						Microsoft RPC
           
                       Hello Example

    FILE:       helloc.c

    USAGE:      helloc  -n network_address
                        -p protocol_sequence
                        -a server principal name
                        -e endpoint
                        -o options
                        -s string_displayed_on_server

    PURPOSE:    Client side of RPC distributed application

    FUNCTIONS:  main() - binds to server and calls remote procedure

    COMMENTS:   This version of the distributed application that
                prints "hello, world" (or other string) on the server
                features a client that manages its connection to the
                server. It uses the binding handle pipedemo_IfHandle,
                defined in the file hello.h.

****************************************************************************/

#define SECURITY_WIN32 1

#include<windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include "hello.h"    // header file generated by MIDL compiler
#include "spn.h"

#define TOTAL_SIZE 0x800
#define BUF_SIZE TOTAL_SIZE
#define PIPE_SIZE TOTAL_SIZE
#define IN_VALUE 0x40

typedef  unsigned long ulong;
typedef void* rpc_ss_pipe_state_t;
// extern RPC_IF_HANDLE PIPEDemo_ClientIfHandle;

long* globalSendPipeData;
long* globalRecvPipeData;
long    globalBuffer[BUF_SIZE];

ulong   pipeDataIndex; /* state variable */


void PipeAlloc(rpc_ss_pipe_state_t stateInfo,
    ulong requestedSize,
    long** allocatedBuffer,
    ulong* allocatedSize)
{
    printf("request size is %d\n", requestedSize);
    ulong* state = (ulong*)stateInfo;
    if (requestedSize > (BUF_SIZE * sizeof(long)))
    {
        *allocatedSize = BUF_SIZE * sizeof(long);
    }
    else
    {
        *allocatedSize = requestedSize;
    }
    *allocatedBuffer = globalBuffer;
} //end PipeAlloc

void PipePull(rpc_ss_pipe_state_t stateInfo,
    long* inputBuffer,
    ulong maxBufSize,
    ulong* sizeToSend)
{
    ulong currentIndex;
    ulong i;
    ulong elementsToRead;
    ulong* state = (ulong*)stateInfo;

    currentIndex = *state;
    printf("Max Buffer size is %d\n",maxBufSize);
    printf("currentIndex is %d\n",currentIndex);
    if (*state >= PIPE_SIZE)
    {
        *sizeToSend = 0; /* end of pipe data */
        *state = 0; /* Reset the state = global index */
    }
    else
    {
        if (currentIndex + maxBufSize > PIPE_SIZE)
            elementsToRead = PIPE_SIZE - currentIndex;
        else
            elementsToRead = maxBufSize;

        for (i = 0; i < elementsToRead; i++)
        {
            /*client sends data */
            inputBuffer[i] = globalSendPipeData[i + currentIndex];
        }

        printf("Now send %d element to server\n", elementsToRead);
        *state += elementsToRead;
        *sizeToSend = elementsToRead;
    }
}//end PipePull

void SendLongs()
{
    LONG_PIPE inPipe;
    int i;
    globalSendPipeData =
        (long*)malloc(sizeof(long) * PIPE_SIZE);

    for (i = 0; i < PIPE_SIZE; i++)
        globalSendPipeData[i] = 0x42424242;

    pipeDataIndex = 0;
    inPipe.state = (rpc_ss_pipe_state_t)&pipeDataIndex;
    inPipe.pull = PipePull;
    inPipe.alloc = PipeAlloc;

    printf("Using inpipe seding....\n");
    InPipe(inPipe); /* Make the rpc */

    free((void*)globalSendPipeData);

}//end SendLongs

// long* globalPipeData;
// long    globalBuffer[BUF_SIZE];

// ulong   pipeDataIndex; /* state variable */
//
//void PipeAlloc(rpc_ss_pipe_state_t stateInfo,
//    ulong requestedSize,
//    long** allocatedBuffer,
//    ulong* allocatedSize)
//{
//    ulong* state = (ulong*)stateInfo;
//    if (requestedSize > (BUF_SIZE * sizeof(long)))
//    {
//        *allocatedSize = BUF_SIZE * sizeof(long);
//    }
//    else
//    {
//        *allocatedSize = requestedSize;
//    }
//    *allocatedBuffer = globalBuffer;
//} //end PipeAlloc

void PipePush(rpc_ss_pipe_state_t stateInfo,
    long* buffer,
    ulong numberOfElements)
{
    ulong elementsToCopy, i;
    ulong* state = (ulong*)stateInfo;

    if (numberOfElements == 0)/* end of data */
    {
        printf("Receive the final one\n");
        *state = 0; /* Reset the state = global index */
    }
    else
    {
        // state is the like the index of the push offset
        if (*state + numberOfElements > PIPE_SIZE)
            elementsToCopy = PIPE_SIZE - *state;
        else
            elementsToCopy = numberOfElements;

        for (i = 0; i < elementsToCopy; i++)
        {
            /*client receives data */
            globalRecvPipeData[*state] = buffer[i];
            (*state)++;
        }
        printf("Receive from server, the first 10 is \n");
        for(int i = 0; i< 10; i++)
        {
            printf("%d,", globalRecvPipeData[i]);
        }
        puts("\n");
    }
}//end PipePush


void ReceiveLongs()
{
    LONG_PIPE outputPipe;
    //idl_long_int i;

    globalRecvPipeData =
        (long*)malloc(sizeof(long) * PIPE_SIZE);

    pipeDataIndex = 0;
    outputPipe.state = (rpc_ss_pipe_state_t)&pipeDataIndex;
    outputPipe.push = PipePush;
    outputPipe.alloc = PipeAlloc;

    OutPipe(&outputPipe); /* Make the rpc */

    free((void*)globalRecvPipeData);

}//end ReceiveLongs()

long * globalInOutData;
void SendAndReceive()
{
    LONG_PIPE inOutPipes;

    globalInOutData = (long*)malloc(sizeof(long)* PIPE_SIZE);
    globalSendPipeData =
        (long*)malloc(sizeof(long) * PIPE_SIZE);

    for (int i = 0; i < PIPE_SIZE; i++)
        globalSendPipeData[i] = 0x42424242;

    globalRecvPipeData =
        (long*)malloc(sizeof(long) * PIPE_SIZE);
    pipeDataIndex = 0;
    inOutPipes.state = (rpc_ss_pipe_state_t)&pipeDataIndex;
    inOutPipes.push = PipePush;
    inOutPipes.pull = PipePull;
    inOutPipes.alloc = PipeAlloc;

    InPipe(inOutPipes);

    OutPipe(&inOutPipes);

    free((void*)globalInOutData);
}


void Usage(char * pszProgramName)
{
    fprintf_s(stderr, "Usage:  %s\n", pszProgramName);
    fprintf_s(stderr, " -p protocol_sequence\n");
    fprintf_s(stderr, " -n network_address\n");
    fprintf_s(stderr, " -e endpoint\n");
    fprintf_s(stderr, " -a server principal name\n");	
    fprintf_s(stderr, " -o options\n");
    fprintf_s(stderr, " -s string\n");
    exit(1);
}

void __cdecl main(int argc, char **argv)
{
    RPC_STATUS status;
    unsigned char * pszUuid             = NULL;
    unsigned char * pszProtocolSequence = "ncacn_ip_tcp";
    unsigned char * pszNetworkAddress   = NULL;
    unsigned char * pszEndpoint         = "9999";
    unsigned char * pszSpn              = NULL;	
    unsigned char * pszOptions          = NULL;
    unsigned char * pszStringBinding    = NULL;
    unsigned char * pszString           = "hello, world";
    RPC_SECURITY_QOS SecQos;
    unsigned long ulCode;
    int i;

    // allow the user to override settings with command line switches
    for (i = 1; i < argc; i++) {
        if ((*argv[i] == '-') || (*argv[i] == '/')) {
            switch (tolower(*(argv[i]+1))) {
            case 'p':  // protocol sequence
                pszProtocolSequence = argv[++i];
                break;
            case 'n':  // network address
                pszNetworkAddress = argv[++i];
                break;
            case 'e':  // endpoint
                pszEndpoint = argv[++i];
                break;
            case 'a':  
                pszSpn = argv[++i];
                break;				
            case 'o':
                pszOptions = argv[++i];
                break;
            case 's':
                pszString = argv[++i];
                break;
            case 'h':
            case '?':
            default:
                Usage(argv[0]);
            }
        }
        else
            Usage(argv[0]);
    }

    // Use a convenience function to concatenate the elements of
    // the string binding into the proper sequence.
    status = RpcStringBindingCompose(pszUuid,
                                     pszProtocolSequence,
                                     pszNetworkAddress,
                                     pszEndpoint,
                                     pszOptions,
                                     &pszStringBinding);
    printf_s("RpcStringBindingCompose returned 0x%x\n", status);
    printf_s("pszStringBinding = %s\n", pszStringBinding);
    if (status) {
        exit(status);
    }

    // Set the binding handle that will be used to bind to the server.
    status = RpcBindingFromStringBinding(pszStringBinding,
                                         &pipedemo_IfHandle);
    printf_s("RpcBindingFromStringBinding returned 0x%x\n", status);
    if (status) {
        exit(status);
    }

    // User did not specify spn, construct one.
    if (pszSpn == NULL) {
        MakeSpn(&pszSpn);
    }

    // RpcBindingSetAuthInfo(
    //     pipedemo_IfHandle,
    //     pszStringBinding,
    //     RPC_C_AUTHN_NONE,
    //     RPC_C_AUTHN_NONE,
    //     RPC_C_AUTHN_NONE,
    //     RPC_C_AUTHN_NONE);
    // Set the quality of service on the binding handle
    SecQos.Version = RPC_C_SECURITY_QOS_VERSION_1;
    SecQos.Capabilities = RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH;
    SecQos.IdentityTracking = RPC_C_QOS_IDENTITY_DYNAMIC;
    SecQos.ImpersonationType = RPC_C_IMP_LEVEL_IDENTIFY;

    // Set the security provider on binding handle
    status = RpcBindingSetAuthInfoEx(pipedemo_IfHandle,
                                     pszSpn,
                                     RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                                     RPC_C_AUTHN_GSS_NEGOTIATE,
                                     NULL,
                                     RPC_C_AUTHZ_NONE,
                                     &SecQos);
	// status = RpcBindingSetAuthInfoEx(pipedemo_IfHandle,
    //                                  pszSpn,
    //                                  RPC_C_AUTHN_LEVEL_NONE,
    //                                  RPC_C_AUTHN_NONE,
    //                                  NULL,
    //                                  RPC_C_AUTHZ_NONE,
    //                                  &SecQos);
    printf_s("RpcBindingSetAuthInfoEx returned %d\n", status);
    if (status) {
        exit(status);
    }	
	
    printf_s("Calling the remote procedure 'HelloProc'\n");
    printf_s("Print the string '%s' on the server\n", pszString);

    RpcTryExcept {
        // HelloProc(pipedemo_IfHandle,pszString);  // make call with user message
        SendLongs();
        // ReceiveLongs();
        // SendAndReceive();
        printf_s("Calling the remote procedure 'Shutdown'\n");
        // Shutdown(pipedemo_IfHandle);  // shut down the server side
    }
    RpcExcept(( ( (RpcExceptionCode() != STATUS_ACCESS_VIOLATION) &&
                   (RpcExceptionCode() != STATUS_DATATYPE_MISALIGNMENT) &&
                   (RpcExceptionCode() != STATUS_PRIVILEGED_INSTRUCTION) &&
                   (RpcExceptionCode() != STATUS_BREAKPOINT) &&
                   (RpcExceptionCode() != STATUS_STACK_OVERFLOW) &&
                   (RpcExceptionCode() != STATUS_IN_PAGE_ERROR) &&
                   (RpcExceptionCode() != STATUS_GUARD_PAGE_VIOLATION)
                    )
                    ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH )) {
        ulCode = RpcExceptionCode();
        printf_s("Runtime reported exception 0x%lx = %ld\n", ulCode, ulCode);

	  
    }
    RpcEndExcept

    //  The calls to the remote procedures are complete.
    //  Free the string and the binding handle
    status = RpcStringFree(&pszStringBinding);  // remote calls done; unbind
    printf_s("RpcStringFree returned 0x%x\n", status);
    if (status) {
        exit(status);
    }

    status = RpcBindingFree(&pipedemo_IfHandle);  // remote calls done; unbind
    printf_s("RpcBindingFree returned 0x%x\n", status);
    if (status) {
        exit(status);
    }
	
    exit(0);

}  // end main()


/*********************************************************************/
/*                 MIDL allocate and free                            */
/*********************************************************************/

void  __RPC_FAR * __RPC_USER midl_user_allocate(size_t len)
{
    return(malloc(len));
}

void __RPC_USER midl_user_free(void __RPC_FAR * ptr)
{
    free(ptr);
}

// end file helloc.c