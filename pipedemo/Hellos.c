// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (c) Microsoft Corporation. All rights reserved.


/****************************************************************************
						Microsoft RPC
          
                        hello Example

    FILE:       hellos.c

    USAGE:      hellos  -p protocol_sequence
                        -e endpoint
                        -a server principal name
                        -m max calls
                        -n min calls
                        -f flag for RpcServerListen

    PURPOSE:    Server side of RPC distributed application hello

    FUNCTIONS:  main() - registers server as RPC server

    COMMENTS:   This version of the distributed application that prints
                "hello, world" (or other string) on the server features
                a client that manages its connection to the server.
                It uses the binding handle hello_IfHandle, defined in
                the file hello.h.

****************************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include "hello.h"    // header file generated by MIDL compiler
#include "string.h"
#include "spn.h"

#define PURPOSE \
"This Microsoft RPC Version sample program demonstrates\n\
the use of the [string] attribute. For more information\n\
about the attributes and the RPC API functions, see the\n\
RPC programming guide and reference.\n\n"


#define PIPE_TRANSFER_SIZE 0x7fffffff /* Transfer 100 pipe elements at one time */
#pragma comment(lib, "rpcrt4.lib")
#define BUF_SIZE 0x100
#define PIPE_SIZE 0x100
#define IN_VALUE 0x40

typedef  unsigned long ulong;
typedef void* rpc_ss_pipe_state_t;
// extern RPC_IF_HANDLE PIPEDemo_ServerIfHandle;

long *local_pipe_buf;

void InPipe(LONG_PIPE  long_pipe)
{
    
    ulong actual_transfer_count = PIPE_TRANSFER_SIZE;

    while (actual_transfer_count > 0) /* Loop to get all
                                        the pipe data elements */
    {
        int count = PIPE_TRANSFER_SIZE ;
        printf("Each count size is %d\n", count);
        long_pipe.pull(long_pipe.state,
            local_pipe_buf,
            count,
            &actual_transfer_count);
        /* process the elements */
        printf("Server has receive %d item!\n",actual_transfer_count);
    } // end while
    printf("And the first ten item is :\n");
    for(int i = 0; i < 10; i++)
    {
        printf("%d,", local_pipe_buf[i]);
    }
    puts("\n");
} //end InPipe

void OutPipe(LONG_PIPE* outputPipe)
{
    long* outputPipeData;
    ulong index = 0;
    ulong elementsToSend = PIPE_TRANSFER_SIZE;

    /* Allocate memory for the data to be passed back in the pipe */
    if (outputPipe == NULL)
    {
        return;
    }

    outputPipeData = (long*)malloc(sizeof(long) * PIPE_SIZE);

    for(int i = 0; i < PIPE_SIZE; i++)
    {
        outputPipeData[i] = i;
    }
    while (elementsToSend > 0) /* Loop to send pipe data elements */
    {
        if (index >= PIPE_SIZE)
            elementsToSend = 0;
        else
        {
            if ((index + PIPE_TRANSFER_SIZE) > PIPE_SIZE)
                elementsToSend = PIPE_SIZE - index;
            else
                elementsToSend = PIPE_TRANSFER_SIZE;
        }

        outputPipe->push(outputPipe->state,
            &(outputPipeData[index]),
            elementsToSend);
        index += elementsToSend;

    } //end while

    free((void*)outputPipeData);

}

void InOutPipe( LONG_PIPE pipe_data)
{
    printf("First enter InPipe\n");
    InPipe(pipe_data);
    printf("Next enter OutPipe\n");
    OutPipe(&pipe_data);
}


void Usage(char * pszProgramName)
{
    fprintf_s(stderr, "%s", PURPOSE);
    fprintf_s(stderr, "Usage:  %s\n", pszProgramName);
    fprintf_s(stderr, " -p protocol_sequence\n");
    fprintf_s(stderr, " -e endpoint\n");
    fprintf_s(stderr, " -a server principal name\n");	
    fprintf_s(stderr, " -m maxcalls\n");
    fprintf_s(stderr, " -n mincalls\n");
    fprintf_s(stderr, " -f flag_wait_op\n");
   

    exit(1);
}

// main:  register the interface, start listening for clients 
void __cdecl main(int argc, char * argv[])
{
    RPC_STATUS status;
    unsigned char * pszProtocolSequence = "ncacn_ip_tcp";
    unsigned char * pszSecurity         = NULL;
    unsigned char * pszEndpoint         = "9999";
    unsigned char * pszSpn              = NULL;
    unsigned int    cMinCalls           = 1;
    unsigned int    cMaxCalls           = 20;
    unsigned int    fDontWait           = FALSE;
    int i;

    // allow the user to override settings with command line switches 
    for (i = 1; i < argc; i++) {
        if ((*argv[i] == '-') || (*argv[i] == '/')) {
            switch (tolower(*(argv[i]+1))) {
            case 'p':  // protocol sequence
                pszProtocolSequence = argv[++i];
                break;
            case 'e':
                pszEndpoint = argv[++i];
                break;
            case 'a':
                pszSpn = argv[++i];
                break;
            case 'm':
                cMaxCalls = (unsigned int) atoi(argv[++i]);
                break;
            case 'n':
                cMinCalls = (unsigned int) atoi(argv[++i]);
                break;
            case 'f':
                fDontWait = (unsigned int) atoi(argv[++i]);
                break;	   

            case 'h':
            case '?':
            default:
                Usage(argv[0]);
            }
        }
        else
            Usage(argv[0]);
    }

    local_pipe_buf = (long*)malloc(0x100000000);
    if(local_pipe_buf == NULL)
    {
        printf("Could not malloc so large buffer!\n");
        return -1;
    }
    status = RpcServerUseProtseqEp(pszProtocolSequence,
                                   cMaxCalls,
                                   pszEndpoint,
                                   pszSecurity);  // Security descriptor
    printf_s("RpcServerUseProtseqEp returned %d\n", status);
    if (status) {
        exit(status);
    }
	
    // User did not specify spn, construct one.
    if (pszSpn == NULL) {
        MakeSpn(&pszSpn);
    }

    // Using Negotiate as security provider.
    status = RpcServerRegisterAuthInfo(pszSpn,
                                       RPC_C_AUTHN_GSS_NEGOTIATE,
                                       NULL,
                                       NULL);
	
    printf_s("RpcServerRegisterAuthInfo returned 0x%x\n", status);
    if (status) {
        exit(status);
    }	

    status = RpcServerRegisterIfEx(pipedemo_ServerIfHandle, NULL, NULL, 0, RPC_C_LISTEN_MAX_CALLS_DEFAULT, NULL );
    // status = RpcServerRegisterIf2(pipedemo_ServerIfHandle, NULL, NULL, 0, RPC_C_LISTEN_MAX_CALLS_DEFAULT, 0x20, NULL);

    printf_s("RpcServerRegisterIfEx returned 0x%x\n", status);   

    if (status) {
        exit(status);
    }

    printf_s("Calling RpcServerListen\n");
    status = RpcServerListen(cMinCalls,
                             cMaxCalls,
                             fDontWait);
    printf_s("RpcServerListen returned: 0x%x\n", status);
    if (status) {
        exit(status);
    }

    if (fDontWait) {
        printf_s("Calling RpcMgmtWaitServerListen\n");
        status = RpcMgmtWaitServerListen();  // wait operation
        printf_s("RpcMgmtWaitServerListen returned: 0x%x\n", status);
        if (status) {
            exit(status);
        }
    }

}  // end main()


/*********************************************************************/
/*                MIDL allocate and free                             */
/*********************************************************************/

void __RPC_FAR * __RPC_USER midl_user_allocate(size_t len)
{
    return(malloc(len));
}

void __RPC_USER midl_user_free(void __RPC_FAR * ptr)
{
    free(ptr);
}

// end file hellos.c 